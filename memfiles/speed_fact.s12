// Author: Caleb Pollock
// Compute factorial using simple 12 instruction set.
// Factorials get large so multiple memory locations 
// are used to store the result. The output is the
// number of memory cells the result contains. The
// result starts at address XX and can be retrieved
// by pulling from the memory locations in ascending order
// via the following loop:
// int factorial = 0
// for (int i = 0; i < output_int_size; ++i) {
//    factorial *= 4096;
//    factorial += sum[i];
// }
// For large numbers some kind of bignum arithmetic must be used
LOAD    0x8D
STORE   0x95
LOAD    0x8C
STORE   0x90
LOAD    0x9A
STORE   0x91
LOAD    0x99
STORE   0x98
LOAD    0x8C
STORE   0x96
STOREI  0x91
STOREI  0x98
LOAD    0x95
SUB     0x8C
STORE   0x94
LOAD    0x8A // start
SUB     0x95
JN      0x7B // goto halt_loc
LOAD    0x8B
STORE   0x93
LOADI   0x91 // addition
STORE   0x92
LOADI   0x98
ADD     0x92
JN      0x1A // goto pass0
JMP     0x2C // goto pass1
ADD     0x8E // pass0
ADD     0x93 
STOREI  0x98
LOAD    0x8B
STORE   0x93
LOAD    0x90 // advance
ADD     0x8C
STORE   0x90
LOAD    0x91 
ADD     0x8C
STORE   0x91
LOAD    0x98
ADD     0x8C
STORE   0x98
LOAD    0x96
SUB     0x90
JN      0x4F // goto check_grow
JMP     0x14 // goto addition
ADD     0x93 // pass1
JN      0x3E // goto pass2
STOREI  0x98
LOAD    0x8B
STORE   0x93
LOAD    0x90 // advance
ADD     0x8C
STORE   0x90
LOAD    0x91 
ADD     0x8C
STORE   0x91
LOAD    0x98
ADD     0x8C
STORE   0x98
LOAD    0x96
SUB     0x90
JN      0x4F // goto check_grow
JMP     0x14 // goto addition
ADD     0x8E // pass2
STOREI  0x98
LOAD    0x8C
STORE   0x93
LOAD    0x90 // advance
ADD     0x8C
STORE   0x90
LOAD    0x91 
ADD     0x8C
STORE   0x91
LOAD    0x98
ADD     0x8C
STORE   0x98
LOAD    0x96
SUB     0x90
JN      0x4F // goto check_grow
JMP     0x14 // goto addition
LOAD    0x93 // check_grow
SUB     0x8C
JN      0x58 // goto next_round
LOAD    0x8F
SUB     0x96
JZ      0x58 // goto next_round
LOAD    0x96
ADD     0x8C
STORE   0x96
LOAD    0x94 // next_round
SUB     0x8C
JZ      0x5D // goto next_value
STORE   0x94
JMP     0x74 // goto next_addition
LOAD    0x95 // next_value
STORE   0x94
ADD     0x8C
STORE   0x95
LOAD    0x9A // copy array 
STORE   0x91
LOAD    0x99
STORE   0x98
LOAD    0x8F
STORE   0x97
LOADI   0x98 // next_copy
STOREI  0x91
LOAD    0x91
ADD     0x8C
STORE   0x91
LOAD    0x98
ADD     0x8C
STORE   0x98
LOAD    0x97
SUB     0x8C
JZ      0x74 // goto next_addition
STORE   0x97
JMP     0x67 // goto next_copy
LOAD    0x9A // next_addition
STORE   0x91
LOAD    0x99
STORE   0x98
LOAD    0x8C
STORE   0x90
JMP     0x0F // goto start
LOAD    0x96 // halt_loc
STORE   0x89
HALT         // xD
0x89: 0 // final array size - output
0x8A: 3 // factorial - user input
0x8B: 0 // zero
0x8C: 1 // one
0x8D: 2 // two
0x8E: 2047 // max
0x8F: 48 // max_int_size
0x90: 0 // pos2
0x91: 0 // pos
0x92: 0 // register
0x93: 0 // carry
0x94: 0 // count2
0x95: 0 // count
0x96: 0 // int_size
0x97: 0 // copy count
0x98: 0 // copy pos
0x99: 0xCD // copy array pos
0x9A: 0x9B // sum pos
0x9B: 0 // sum start - all values below this are sum
0xCD: 0 // copy start - all values below this are the copy
