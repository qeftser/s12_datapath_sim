// GROUP MEMBERS: Daniel Uranga, Praba Arumugam, Shimoli Shinde, William Ostrum 
// SECTION: ECE532 
//
// DESCRIPTION: 
// Given a list of n numbers stored in addresses 0xFF-(n) to 0xFF -1, 
// and the value n stored in 0xFF, sort the n numbers from smallest to largest. 
// Store the final sorted list in address 0xFF-(n) to 0xFF -1
// with smallest value at 0xFF-(n) and largest at 0xFF-1

// This code uses SELECTION SORT algorithm and is optimized for memory usage.
//==================================================================================================================================
//
// MEMORY MAP FOR VARIABLES (reuse as much as possible):
// 0xE6 : 1 (constant 1)
// 0xE7 : 0 (constant 0)
// 0xE8 : i (outer index)
// 0xE9 : j (inner index)
// 0xEA : minIdx (index of current minimum)
// 0xEB : tmp (temporary storage for swapping)
// 0xEC : addr (address scratch register)
// 0xFF : n (size of array)
// 0xF0..0xFE : data elements
//
//==================================================================================================================================

// ----- initialize i = 0 -----
LOAD  0xE7          // A = ZERO (0)
STORE 0xE8          // i = 0

OUTER_LOOP:
    // ----- stop when i >= n-1 -----
    LOAD  0xFF      // A = n
    SUB   0xE6      // A = n - 1
    SUB   0xE8      // A = (n - 1) - i
    JN    DONE      // if (n-1) - i < 0  => i > n-1, end
                
    // ----- minIdx = i -----
    LOAD  0xE8      // A = i
    STORE 0xEA      // minIdx = i

    // ----- j = i + 1 -----
    LOAD  0xE8      // A = i
    ADD   0xE6      // A = i + 1
    STORE 0xE9      // j = i + 1

INNER_LOOP:
    // ----- break inner loop when j >= n -----
    LOAD  0xFF      // A = n
    SUB   0xE9      // A = n - j
    JN    INNER_DONE// if n - j < 0 => j > n, (defensive) stop

    // ----- tmp = A[j]  (load element at index j) -----
    LOAD  0xF0      // A = base (numeric 0xF0)  *see note at top*
    ADD   0xE9      // A = base + j
    STORE 0xEC      // addr = base + j
    LOADI 0xEC      // A = M[addr] = a[j]
    STORE 0xEB      // tmp = a[j]

    // ----- compare a[j] against a[minIdx] -----
    LOAD  0xF0      // A = base
    ADD   0xEA      // A = base + minIdx
    STORE 0xEC      // addr = base + minIdx
    LOADI 0xEC      // A = a[minIdx]
    SUB   0xEB      // A = a[minIdx] - tmp  (tmp = a[j])
    JN    UPDATE_MIN// if a[minIdx] - a[j] < 0  ==> a[minIdx] < a[j], keep minIdx (NO update)

NEXT_J:
    // ----- j++ and continue scanning -----
    LOAD  0xE9      // A = j
    ADD   0xE6      // A = j + 1
    STORE 0xE9      // j = j + 1
    JMP   INNER_LOOP

UPDATE_MIN:
    // ----- minIdx = j (found a new minimum) -----
    LOAD  0xE9      // A = j
    STORE 0xEA      // minIdx = j
    JMP   NEXT_J    // keep scanning the rest 

INNER_DONE:
    // ----- if minIdx == i, no swap needed -----
    LOAD  0xE8      // A = i
    SUB   0xEA      // A = i - minIdx
    JZ    SKIP_SWAP // if zero, same index -> nothing to swap

    // ----- tmp = a[i] -----
    LOAD  0xF0      // A = base
    ADD   0xE8      // A = base + i
    STORE 0xEC      // addr = base + i
    LOADI 0xEC      // A = a[i]
    STORE 0xEB      // tmp = a[i]

    // ----- a[i] = a[minIdx] -----
    LOAD  0xF0      // A = base
    ADD   0xEA      // A = base + minIdx
    STORE 0xEC      // addr = base + minIdx
    LOADI 0xEC      // A = a[minIdx]
    LOAD  0xF0      // A = base
    ADD   0xE8      // A = base + i
    STORE 0xEC      // addr = base + i
    STOREI 0xEC     // M[addr] = A  => a[i] = a[minIdx]

    // ----- a[minIdx] = tmp -----
    LOAD  0xF0      // A = base
    ADD   0xEA      // A = base + minIdx
    STORE 0xEC      // addr = base + minIdx
    LOAD  0xEB      // A = tmp
    STOREI 0xEC     // M[addr] = A  => a[minIdx] = tmp

SKIP_SWAP:
    // ----- i++ and start next outer pass -----
    LOAD  0xE8      // A = i
    ADD   0xE6      // A = i + 1
    STORE 0xE8      // i = i + 1
    JMP   OUTER_LOOP

DONE:
    HALT        