// Author: Caleb Pollock
// Compute factorial using simple 12 instruction set.
// Factorials get large so multiple memory locations 
// are used to store the result. The output is the
// number of memory cells the result contains. The
// result starts at address XX and can be retrieved
// by pulling from the memory locations in ascending order
// via the following loop:
// int factorial = 0
// for (int i = 0; i < output_int_size; ++i) {
//    factorial *= 4096;
//    factorial += sum[i];
// }
// For large numbers some kind of bignum arithmetic must be used
LOAD    0x6A
STORE   0x72
LOAD    0x69
STORE   0x6D
LOAD    0x77
STORE   0x6E
LOAD    0x76
STORE   0x75
LOAD    0x69
STORE   0x73
STOREI  0x6E
STOREI  0x75
LOAD    0x72
SUB     0x69
STORE   0x71
LOAD    0x67 // start
SUB     0x72
JN      0x63 // goto halt_loc
LOAD    0x68
STORE   0x70
LOADI   0x6E // addition
STORE   0x6F
LOADI   0x75
ADD     0x6F
JN      0x1A // goto pass0
JMP     0x20 // goto pass1
ADD     0x6B // pass0
ADD     0x70 
STOREI  0x75
LOAD    0x68
STORE   0x70
JMP     0x2A // goto advance
ADD     0x70 // pass1
JN      0x26 // goto pass2
STOREI  0x75
LOAD    0x68
STORE   0x70
JMP     0x2A // goto advance
ADD     0x6B // pass2
STOREI  0x75
LOAD    0x69
STORE   0x70
LOAD    0x6D // advance
ADD     0x69
STORE   0x6D
LOAD    0x6E 
ADD     0x69
STORE   0x6E
LOAD    0x75
ADD     0x69
STORE   0x75
LOAD    0x73
SUB     0x6D
JN      0x37 // goto check_grow
JMP     0x14 // goto addition
LOAD    0x70 // check_grow
SUB     0x69
JN      0x40 // goto next_round
LOAD    0x6C
SUB     0x73
JZ      0x40 // goto next_round
LOAD    0x73
ADD     0x69
STORE   0x73
LOAD    0x71 // next_round
SUB     0x69
JZ      0x45 // goto next_value
STORE   0x71
JMP     0x5C // goto next_addition
LOAD    0x72 // next_value
STORE   0x71
ADD     0x69
STORE   0x72
LOAD    0x77 // copy array 
STORE   0x6E
LOAD    0x76
STORE   0x75
LOAD    0x6C
STORE   0x74
LOADI   0x75 // next_copy
STOREI  0x6E
LOAD    0x6E
ADD     0x69
STORE   0x6E
LOAD    0x75
ADD     0x69
STORE   0x75
LOAD    0x74
SUB     0x69
JZ      0x5C // goto next_addition
STORE   0x74
JMP     0x4F // goto next_copy
LOAD    0x77 // next_addition
STORE   0x6E
LOAD    0x76
STORE   0x75
LOAD    0x69
STORE   0x6D
JMP     0x0F // goto start
LOAD    0x73 // halt_loc
STORE   0x66
HALT         // xD
0x66: 0 // final array size - output
0x67: 6 // factorial - user input
0x68: 0 // zero
0x69: 1 // one
0x6A: 2 // two
0x6B: 2047 // max
0x6C: 67 // max_int_size
0x6D: 0 // pos2
0x6E: 0 // pos
0x6F: 0 // register
0x70: 0 // carry
0x71: 0 // count2
0x72: 0 // count
0x73: 0 // int_size
0x74: 0 // copy count
0x75: 0 // copy pos
0x76: 0xBD // copy array pos
0x77: 0x78 // sum pos
0x78: 0 // sum start - all values below this are sum
0xBD: 0 // copy start - all values below this are the copy
